<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<title>2d test</title>

</head>
<body style="margin: 0;">
	<canvas id="game" style="position: fixed"></canvas>
	<script>
    var ctx = null;
    //var myAnim;
    var movingToX, movingToY;
    var tileW = 80, tileH = 80; // 169 291
    var mapW = 30, mapH = 30;
    var stepX = 0, stepY = 0;
    var startSpeed = 3;
    var bodySize = 0.6;
    let frameX = 0;
    var speed = startSpeed;
    var canvas = document.getElementById('game');
    var screenW = document.documentElement.clientWidth;
    var screenH = document.documentElement.clientHeight;
    canvas.width = screenW; // window.innerWidth document.body.clientWidth
    canvas.height = screenH; // window.innerHeight document.body.clientHeight
    const playerImage = new Image();
    playerImage.src = 'img/bunny.png';
    const carrotImg = new Image();
    carrotImg.src = 'img/carrot.png';
    const imgPatt = new Image();
    imgPatt.src = 'img/pattern.jpg';
    const imgRock = new Image();
    imgRock.src = 'img/rock.jpg';
    
    var currentSecond = 0, frameCount = 0, frameLastSecond = 0;
    var lastMoveTime = 0;
    var lastRunSecond = 0;
    var mapLimit = 7700;
    var currentX = randomIntBetween(1000, mapLimit-1000);
    var currentY = randomIntBetween(1000, mapLimit-1000);
    currentX = 500;
    currentY = 500;
    //console.log(currentX);
    //console.log(currentY);
    
    var foodMap = [];
    var shitMap = [];
    for(var i=0; i<50; i++){
        foodMap.push(randomIntBetween(400, mapLimit-400), randomIntBetween(400, mapLimit-400));
    }
  
    document.addEventListener('DOMContentLoaded', function(event) {
        ctx = canvas.getContext('2d');
        
        drawGame();
    });
    
    window.addEventListener("keydown", function(e){
        if(e.keyCode === 32){
            speed = startSpeed*2;
        }
    });
    window.addEventListener("keyup", function(e){
        if(e.keyCode === 32){
            speed = startSpeed;
        }
    });
    
    canvas.addEventListener('mousemove', function(e){
        var now = Date.now();
        if(now - lastMoveTime < 60){ // 60ms
            return;
        }
        lastMoveTime = now;
        movingToX = e.clientX;
        movingToY = e.clientY;
    });
    
    /*canvas.addEventListener('mouseout', function(e){
        movingToX = 0;
        movingToY = 0;
    });*/
    
    function drawGame(){        
        var sec = Math.floor(Date.now()/1000);
        if(sec != currentSecond){
            currentSecond = sec;
            frameLastSecond = frameCount;
            frameCount = 1;
            if(speed > startSpeed){
                lastRunSecond = sec;
                shitMap.push(currentX, currentY);
                bodySize -= 0.005;
                if(shitMap.length > 12){
                    shitMap.shift();
                    shitMap.shift();
                }
            }else if(shitMap.length && sec - lastRunSecond > 10){
                shitMap.shift();
                shitMap.shift();
            }
        }else{
            frameCount++;
        }
        
        var direct = 0;
        if(movingToX || movingToY){
            var diffX = movingToX - screenW/2;
            var diffY = movingToY - screenH/2;
            var sX = 0;
            var sY = 0;
            if(diffX !== 0 && diffY !== 0){
                if(Math.abs(diffY) > Math.abs(diffX)){
                    sX = Math.abs(diffX/diffY);
                    sY = 1;
                    direct = diffY > 0 ? 2 : 0;
                }else{
                    sX = 1;
                    sY = Math.abs(diffY/diffX);
                    direct = diffX > 0 ? 1 : 3;
                }
                if(diffX > 0){
                    if(currentX+10 < mapLimit){
                        currentX += speed*sX;
                        stepX -= speed*sX;
                    }
                }else{
                    if(currentX-10 > 0){
                        currentX -= speed*sX;
                        stepX += speed*sX;
                    }
                }
                if(diffY > 0){
                    if(currentY+10 < mapLimit){
                        currentY += speed*sY;
                        stepY -= speed*sY;
                    }
                }else{
                    if(currentY-10 > 0){
                        currentY -= speed*sY;
                        stepY += speed*sY;
                    }
                }
            }else if(diffX !== 0){
                if(diffX > 0){
                    if(currentX+10 < mapLimit){
                        currentX += speed*sX;
                        stepX -= speed*sX;
                    }
                    direct = 3;
                }else{
                    if(currentX-10 > 0){
                        currentX -= speed*sX;
                        stepX += speed*sX;
                    }
                    direct = 1;
                }
            }else if(diffY !== 0){ 
                if(diffY > 0){
                    if(currentY+10 < mapLimit){
                        currentY += speed*sY;
                        stepY -= speed*sY;
                    }
                    direct = 0;
                }else{
                    if(currentY-10 > 0){
                        currentY -= speed*sY;
                        stepY += speed*sY;
                    }
                    direct = 2;
                }
            }
            
            /*if(Math.abs(stepX) > tileW){ // tileW*2
                stepX = stepX > 0 ? stepX - tileW : stepX + tileW;
            }
            if(Math.abs(stepY) > tileH){ // tileH*2
                stepY = stepY > 0 ? stepY - tileH : stepY + tileH;
            }*/
            if(Math.abs(stepX) > tileW*2){
                stepX = stepX > 0 ? stepX - tileW*2 : stepX + tileW*2;
            }
            if(Math.abs(stepY) > tileH*2){
                stepY = stepY > 0 ? stepY - tileH*2 : stepY + tileH*2;
            }
        }
        
        // Background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        /*const pattern = ctx.createPattern(imgPatt, 'repeat');
        ctx.fillStyle = pattern;
        ctx.translate(stepX, stepY);
        ctx.fillRect(-tileW, -tileH, canvas.width+(tileW*2), canvas.height+(tileH*2));
        */
        ctx.globalAlpha = 0.5;
        var state = 0;
        for(var y=-2.5; y < mapH; y++){
            for(var x=-2.5; x < mapW; x++){
                if(state === 0){
                    ctx.fillStyle = 'rgba(150,150,150,0.45)';
                    state = 1;
                }else{
                    ctx.fillStyle = 'rgba(238,238,238,0.45)';
                    state = 0;
                }
                ctx.fillRect(x*tileW+stepX, y*tileH+stepY, tileW, tileH);
            }
        }
        ctx.restore();
        
        // Borders
        
        ctx.lineWidth = 700;
        //ctx.globalCompositeOperation = 'lighter';
        if(currentX - screenW/2 < 0){
            var lineX = screenW/2 - currentX;
            /*ctx.beginPath();
            ctx.moveTo(lineX, 0);
            ctx.lineTo(lineX, screenH);
            ctx.stroke();*/
            
            ctx.save();
            /*ctx.fillStyle = ctx.createPattern(imgRock, 'repeat');
            ctx.translate(lineX-700, (screenH/2 - (currentY % 700)) - 700);
            ctx.fillRect(0, 0, 700, screenH+1400);*/
            const pRock = ctx.createPattern(imgRock, 'repeat');
            ctx.strokeStyle = pRock;
            //ctx.lineWidth = 700;
            ctx.beginPath();
            ctx.translate(lineX-700, (screenH/2 - (currentY % 700)) - 700);
            ctx.moveTo(350, 0);
            ctx.lineTo(350, screenH+1400);
            ctx.stroke();
            ctx.restore();
            
        }else if(currentX + screenW/2 > mapLimit){
            var lineX = screenW/2 + (mapLimit - currentX);
            /*ctx.beginPath();
            ctx.moveTo(lineX, 0);
            ctx.lineTo(lineX, screenH);
            ctx.stroke();*/
            
            ctx.save();
            const pRock = ctx.createPattern(imgRock, 'repeat');
            ctx.strokeStyle = pRock;
            //ctx.lineWidth = 700;
            ctx.beginPath();
            ctx.translate(lineX-700, (screenH/2 - (currentY % 700)) - 700);
            ctx.moveTo(lineX+350 - (lineX-700), 0);
            ctx.lineTo(lineX+350 - (lineX-700), screenH+1400);
            ctx.stroke();
            ctx.restore();
        }
        if(currentY - screenH/2 < 0){
            var lineY = screenH/2 - currentY;
            /*ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(screenW, lineY);
            ctx.stroke();*/
            
            ctx.save();
            const pRock = ctx.createPattern(imgRock, 'repeat');
            ctx.strokeStyle = pRock;
            //ctx.lineWidth = 700;
            ctx.beginPath();
            ctx.translate((screenW/2 - (currentX % 700)) - 1400, lineY-700);
            ctx.moveTo(0, 350);
            ctx.lineTo(screenW+1400, 350);
            ctx.stroke();
            ctx.restore();
        }else if(currentY + screenH/2 > mapLimit){
            var lineY = screenH/2 + (mapLimit - currentY);
            /*ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(screenW, lineY);
            ctx.stroke();*/
            
            ctx.save();     
            const pRock = ctx.createPattern(imgRock, 'repeat');
            ctx.strokeStyle = pRock;
            //ctx.lineWidth = 700;
            ctx.beginPath();
            ctx.translate((screenW/2 - (currentX % 700)) - 1400, lineY-700);
            ctx.moveTo(0, lineY+350 - (lineY-700));
            ctx.lineTo(screenW+1400, lineY+350 - (lineY-700));
            ctx.stroke();
            ctx.restore();
        }
        
        ctx.save();
        ctx.shadowColor = '#523A28';
        ctx.shadowBlur = 12;
        
        // Character
        /*ctx.beginPath();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = '#00B29D';
        ctx.lineWidth = 3;
        ctx.arc(screenW/2, screenH/2, bodySize, 0, 2*Math.PI);
        ctx.stroke();
        ctx.closePath();*/
        ctx.drawImage(playerImage, 48*frameX, 64*direct, 48, 64, screenW/2-(48*bodySize/2), screenH/2-(64*bodySize/2), 48*bodySize, 64*bodySize);
        var eachFrame = speed === startSpeed ? 12 : 7;
        if(frameCount % eachFrame == 0){
            if(frameX<2){
                frameX++;
            }else{
                frameX = 0;
            }
        }
        
        // Food
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = '#ffa723'; // orange
        for(var i=0; i<100; i=i+2){
            if(Math.abs(currentX - foodMap[i]) < screenW/2 && Math.abs(currentY - foodMap[i+1]) < screenH/2){
                if(Math.abs(currentX - foodMap[i]) < 14 && Math.abs(currentY - foodMap[i+1]) < 20){
                    foodMap[i] = randomIntBetween(400, mapLimit-400);
                    foodMap[i+1] = randomIntBetween(400, mapLimit-400);
                    if(bodySize < 1){
                        bodySize += 0.02;
                    }
                    continue;   
                }
                var foodX = (currentX > foodMap[i]) ? screenW/2 - (currentX - foodMap[i]) : screenW/2 + (foodMap[i] - currentX);
                var foodY = (currentY > foodMap[i+1]) ? screenH/2 - (currentY - foodMap[i+1]) : screenH/2 + (foodMap[i+1] - currentY);
                /*ctx.beginPath();
                ctx.ellipse(foodX, foodY, 5, 7, Math.PI / 4, 0, 2 * Math.PI);
                ctx.stroke();*/
                ctx.drawImage(carrotImg, foodX-11.5, foodY-11.5);
            }
        }
        
        // Shit
        ctx.fillStyle = '#523A28';
        for(var i=0; i<shitMap.length; i=i+2){
            if(Math.abs(currentX - shitMap[i]) < screenW/2 && Math.abs(currentY - shitMap[i+1]) < screenH/2){
                var shitX = (currentX > shitMap[i]) ? screenW/2 - (currentX - shitMap[i]) : screenW/2 + (shitMap[i] - currentX);
                var shitY = (currentY > shitMap[i+1]) ? screenH/2 - (currentY - shitMap[i+1]) : screenH/2 + (shitMap[i+1] - currentY);
                
                ctx.beginPath();
                ctx.ellipse(shitX, shitY+15, 5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
        
        //ctx.fillStyle = '#ff0000';
        //ctx.fillText("FPS: "+frameLastSecond, 10, 20);
        
        requestAnimationFrame(drawGame);
    }
    
    function randomIntBetween(min, max) { // min and max included 
      return Math.floor(Math.random() * (max - min + 1) + min)
    }
    
	</script>
</body>
</html>
